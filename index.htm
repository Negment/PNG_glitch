<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>PNG Destroyer v14</title>
    <style>
        :root { --accent: #00ff00; --bg: #000; --panel: #111; --text: #eee; }
        body { background: var(--bg); color: var(--text); font-family: 'Consolas', monospace; margin: 0; display: flex; height: 100vh; font-size: 10px; overflow: hidden; }
        .sidebar { width: 440px; background: var(--panel); border-right: 1px solid #222; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; box-shadow: 10px 0 30px #000; z-index: 10; }
        .viewport { flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #080808; padding: 10px; }
        h1 { font-size: 1.2rem; border-left: 5px solid var(--accent); padding-left: 12px; margin: 0; color: var(--accent); letter-spacing: 2px; }
        .master-group { background: #1a0000; border: 2px solid var(--accent); padding: 15px; border-radius: 4px; margin-bottom: 10px; box-shadow: 0 0 15px rgba(0,255,0,0.2); }
        .master-label { font-size: 11px; font-weight: 900; color: #fff !important; text-transform: uppercase; letter-spacing: 3px; }
        .group { background: #0a0a0a; border: 1px solid #222; padding: 10px; border-radius: 2px; }
        .group-title { font-weight: bold; margin-bottom: 8px; color: #666; border-bottom: 1px solid #333; padding-bottom: 4px; text-transform: uppercase; font-size: 9px; }
        .ctrl-row { display: flex; align-items: center; gap: 5px; margin-bottom: 2px; }
        label { flex-grow: 1; display: flex; justify-content: space-between; color: #999; }
        .reset-mini { background: #222; color: #555; border: none; font-size: 8px; cursor: pointer; padding: 2px 4px; }
        .reset-mini:hover { background: var(--accent); color: #000; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; height: 3px; margin: 4px 0 8px 0; }
        canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; }
        .val { color: var(--accent); font-weight: bold; min-width: 30px; text-align: right; }
        .btn-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 5px; }
        button { background: #1a1a1a; color: #fff; border: 1px solid #333; padding: 10px; cursor: pointer; font-family: inherit; font-size: 9px; font-weight: bold; }
        button:hover { background: var(--accent); color: #000; }
        input[type="file"] { font-size: 9px; color: #555; background: #000; padding: 8px; border: 1px solid #222; width: 100%; box-sizing: border-box; }
    </style>
</head>
<body>

<div class="sidebar">
    <h1>PNG DESTROYER</h1>
    <div style="font-size:9px; color:#444; margin-bottom:10px;">LOOP_SYNC_V14.0</div>
    <input type="file" id="upload" accept="image/*">
    <div class="master-group">
        <div class="ctrl-row"><label class="master-label">Global Corruption <span class="val" id="v-master">0</span>%</label></div>
        <input type="range" id="master" min="0" max="100" value="0" step="1">
    </div>
    <div class="btn-row">
        <button id="random">RANDOM</button>
        <button id="reset-all">RESET ALL</button>
        <button id="download">SAVE PNG</button>
    </div>
    <div id="controls"></div>
</div>

<div class="viewport">
    <canvas id="canvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let originalImageData = null;

    const defs = [
        {id:'prob',   n:'Trigger Prob.', d:100, min:0, max:100, s:1, c:'1. Signal Destruction'},
        {id:'stable', n:'Stability',    d:0,   min:0, max:300, s:1, c:'1. Signal Destruction'},
        {id:'stableJ',n:'Stab. Jitter', d:0,   min:0, max:200, s:1, c:'1. Signal Destruction'},
        {id:'type',   n:'Filter Mode',  d:1,   min:0, max:4,   s:1, c:'1. Signal Destruction'},
        {id:'skew',   n:'Stride Skew',  d:0,   min:-100,max:100,s:1, c:'2. Geometry Distortion'},
        {id:'slide',  n:'Square Slide', d:0,   min:0, max:1000,s:1, c:'2. Geometry Distortion'},
        {id:'sync',   n:'Scanline Jitter',d:0, min:0, max:100, s:1, c:'2. Geometry Distortion'},
        {id:'chunk',  n:'Chunk Size',   d:10,  min:1, max:500, s:1, c:'2. Geometry Distortion'},
        {id:'rgb',    n:'RGB Split',    d:0,   min:0, max:300, s:1, c:'3. Chromatic Chaos'},
        {id:'echo',   n:'Signal Ghost', d:0,   min:0, max:100, s:1, c:'3. Chromatic Chaos'},
        {id:'shuffle',n:'Chan. Shuffle',d:0,   min:0, max:5,   s:1, c:'3. Chromatic Chaos'},
        {id:'flop',   n:'Bit Flop (V)', d:0,   min:0, max:8,   s:1, c:'3. Chromatic Chaos'},
        {id:'mult',   n:'Overflow Mult',d:1,   min:1, max:10,  s:0.1,c:'4. Binary Erosion'},
        {id:'bit',    n:'XOR Noise',    d:0,   min:0, max:8,   s:1, c:'4. Binary Erosion'},
        {id:'crush',  n:'Bit Crush',    d:0,   min:0, max:7,   s:1, c:'4. Binary Erosion'},
        {id:'melt',   n:'Acid Melt',    d:0,   min:0, max:255, s:1, c:'5. Data Decay'},
        {id:'sort',   n:'Sort Thresh.', d:0,   min:0, max:255, s:1, c:'5. Data Decay'},
        {id:'void',   n:'Void Offset',  d:0,   min:-255,max:255,s:1, c:'5. Data Decay'},
        {id:'inv',    n:'Death Thresh.',d:255, min:0, max:255, s:1, c:'5. Data Decay'}
    ];

    const cfg = {};
    let masterPower = 0;
    const controlContainer = document.getElementById('controls');
    let currentCat = "";

    defs.forEach(d => {
        if(d.c !== currentCat){
            currentCat = d.c;
            const title = document.createElement('div');
            title.className = 'group-title'; title.innerText = d.c;
            controlContainer.appendChild(title);
        }
        const box = document.createElement('div');
        box.className = 'group';
        box.innerHTML = `<div class="ctrl-row"><label>${d.n} <span class="val" id="v-${d.id}">${d.d}</span></label>
            <button class="reset-mini" onclick="resetParam('${d.id}', ${d.d})">R</button></div>
            <input type="range" id="${d.id}" min="${d.min}" max="${d.max}" value="${d.d}" step="${d.s}">`;
        controlContainer.appendChild(box);
        cfg[d.id] = d.d;
    });

    document.getElementById('master').oninput = (e) => {
        masterPower = parseFloat(e.target.value) / 100;
        document.getElementById('v-master').innerText = e.target.value;
        applyGlitch();
    };

    window.resetParam = (id, def) => {
        const el = document.getElementById(id);
        el.value = def; cfg[id] = def;
        document.getElementById(`v-${id}`).innerText = def;
        applyGlitch();
    };

    defs.forEach(d => {
        document.getElementById(d.id).oninput = (e) => {
            cfg[d.id] = parseFloat(e.target.value);
            document.getElementById(`v-${d.id}`).innerText = e.target.value;
            applyGlitch();
        };
    });

    document.getElementById('reset-all').onclick = () => {
        document.getElementById('master').value = 0; masterPower = 0;
        document.getElementById('v-master').innerText = 0;
        defs.forEach(d => resetParam(d.id, d.d));
    };

    document.getElementById('random').onclick = () => {
        defs.forEach(d => {
            const el = document.getElementById(d.id);
            const r = (Math.random() * (d.max - d.min) + d.min);
            el.value = d.s === 1 ? Math.floor(r) : r.toFixed(1);
            cfg[d.id] = parseFloat(el.value);
            document.getElementById(`v-${d.id}`).innerText = el.value;
        });
        applyGlitch();
    };

    document.getElementById('upload').onchange = (e) => {
        const file = e.target.files[0]; if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width; canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                originalImageData = ctx.getImageData(0, 0, img.width, img.height);
                applyGlitch();
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    };

    document.getElementById('download').onclick = () => {
        canvas.toBlob((blob) => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `PNG_DESTROYER_V14_${Date.now()}.png`;
            link.click();
        }, 'image/png');
    };

    // ヘルパー: 座標x, yを画像サイズw, hに回り込ませ、RGBA配列の先頭インデックスを返す
    function getIdx(x, y, w, h) {
        const nx = (Math.floor(x) % w + w) % w;
        const ny = (Math.floor(y) % h + h) % h;
        return (ny * w + nx) * 4;
    }

    function applyGlitch() {
        if (!originalImageData) return;
        const { width, height, data } = originalImageData;
        const out = new ImageData(new Uint8ClampedArray(data), width, height);

        const eff = {};
        defs.forEach(d => {
            const current = cfg[d.id];
            eff[d.id] = d.d + (current - d.d) * masterPower;
        });

        // PASS 1: Horizontal & Binary Reconstruction (Slide, Skew, Sync, Filters)
        for (let y = 0; y < height; y++) {
            if (Math.random() * 100 > eff.prob) continue;

            const skew = y * (eff.skew / 10);
            const sync = (y % 2 === 0) ? eff.sync : -eff.sync;
            const xShift = (Math.floor(y / eff.chunk) % 2 === 0) ? eff.slide : 0;
            const totalShift = xShift + skew + sync;

            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const ti = getIdx(x + totalShift, y, width, height);
                
                let r = data[ti], g = data[ti+1], b = data[ti+2];

                // Stability (PNG Filter) - Loop neighboring calculated pixels
                if (eff.stable > 0) {
                    const s = (eff.stable + (Math.random()-0.5)*eff.stableJ)/100;
                    const piX = getIdx(x - 1, y, width, height);
                    const piY = getIdx(x, y - 1, width, height);
                    let rr, rg, rb;
                    if(cfg.type==1) { rr=out.data[piX]; rg=out.data[piX+1]; rb=out.data[piX+2]; }
                    else if(cfg.type==2) { rr=out.data[piY]; rg=out.data[piY+1]; rb=out.data[piY+2]; }
                    else if(cfg.type==3) { rr=(out.data[piY]+out.data[piX])/2; rg=(out.data[piY+1]+out.data[piX+1])/2; rb=(out.data[piY+2]+out.data[piX+2])/2; }
                    else { rr=Math.abs(out.data[piY]-out.data[piX]); rg=Math.abs(out.data[piY+1]-out.data[piX+1]); rb=Math.abs(out.data[piY+2]-out.data[piX+2]); }
                    r = (r + rr * s) % 256; g = (g + rg * s) % 256; b = (b + rb * s) % 256;
                }

                if (eff.mult !== 1) { r=(r*eff.mult)%256; g=(g*eff.mult)%256; b=(b*eff.mult)%256; }
                if (eff.crush > 0) { const m = 0xFF << Math.floor(eff.crush); r&=m; g&=m; b&=m; }
                if (eff.bit > 0) { r^=(r>>eff.bit); g^=(g>>eff.bit); b^=(b>>eff.bit); }
                if (eff.flop > 0 && Math.random()*10 < eff.flop) r ^= 0xFF; 

                out.data[i] = r; out.data[i+1] = g; out.data[i+2] = b; out.data[i+3] = 255;
            }
        }

        // PASS 2: Vertical & Sorting (Melt, Sort, RGB, Ghost)
        const temp = new Uint8ClampedArray(out.data);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;

                // Acid Melt - Loops vertically
                if (eff.melt > 0) {
                    const up = getIdx(x, y - 1, width, height);
                    if (Math.abs(temp[i] - out.data[up]) < eff.melt) {
                        out.data[i]=out.data[up]; out.data[i+1]=out.data[up+1]; out.data[i+2]=out.data[up+2];
                    }
                }
                // Sort - Loops horizontally
                if (eff.sort > 0) {
                    const prev = getIdx(x - 1, y, width, height);
                    if (Math.abs(out.data[i] - out.data[prev]) < eff.sort) {
                        out.data[i]=out.data[prev]; out.data[i+1]=out.data[prev+1]; out.data[i+2]=out.data[prev+2];
                    }
                }
                // RGB / Ghost / Shuffle - Fully looped
                if (eff.rgb > 0 || eff.echo > 0 || cfg.shuffle > 0) {
                    const shiftX = Math.floor(eff.rgb);
                    const shiftY = Math.floor(eff.echo / 2);
                    const ri = getIdx(x + shiftX, y - shiftY, width, height);
                    const bi = getIdx(x - shiftX, y, width, height);
                    let r = temp[ri], g = temp[i+1], b = temp[bi+2];
                    if (cfg.shuffle > 0) {
                        let c = [r, g, b];
                        if (cfg.shuffle == 1) c = [r, b, g]; else if (cfg.shuffle == 2) c = [g, r, b];
                        else if (cfg.shuffle == 3) c = [g, b, r]; else if (cfg.shuffle == 4) c = [b, r, g];
                        else if (cfg.shuffle == 5) c = [b, g, r];
                        r = c[0]; g = c[1]; b = c[2];
                    }
                    out.data[i]=r; out.data[i+1]=g; out.data[i+2]=b;
                }
                // Void & Death
                let fr=out.data[i]+eff.void, fg=out.data[i+1]+eff.void, fb=out.data[i+2]+eff.void;
                if(fr > eff.inv) fr=255-fr; if(fg > eff.inv) fg=255-fg; if(fb > eff.inv) fb=255-fb;
                out.data[i]=fr; out.data[i+1]=fg; out.data[i+2]=fb;
            }
        }
        ctx.putImageData(out, 0, 0);
    }
</script>
</body>
</html>
