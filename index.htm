<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>PNG Destroyer v10</title>
    <style>
        :root { --accent: #ff0044; --bg: #030303; --panel: #111; --text: #ddd; }
        body { background: var(--bg); color: var(--text); font-family: 'Consolas', monospace; margin: 0; display: flex; height: 100vh; font-size: 10px; overflow: hidden; }
        
        .sidebar { width: 420px; background: var(--panel); border-right: 1px solid #222; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; box-shadow: 10px 0 30px rgba(0,0,0,0.7); z-index: 10; }
        .viewport { flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #000; padding: 10px; position: relative; }
        
        h1 { font-size: 1.3rem; border-left: 5px solid var(--accent); padding-left: 12px; margin: 0; letter-spacing: 2px; color: var(--accent); font-weight: 900; }
        .version { font-size: 9px; color: #555; margin-bottom: 10px; }

        .group { background: #0a0a0a; border: 1px solid #1a1a1a; padding: 10px; border-radius: 2px; }
        .group-title { font-weight: bold; margin-bottom: 8px; color: #666; border-bottom: 1px solid #222; padding-bottom: 4px; text-transform: uppercase; font-size: 9px; letter-spacing: 1px; }
        
        label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1px; color: #999; }
        input[type="range"] { width: 100%; accent-color: var(--accent); cursor: pointer; height: 3px; margin: 6px 0 10px 0; }
        
        canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; box-shadow: 0 0 60px rgba(255,0,0,0.15); }
        .val { color: var(--accent); font-weight: bold; font-family: monospace; background: #1a1a1a; padding: 1px 4px; border-radius: 2px; }
        
        .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 5px; }
        button { background: #1a1a1a; color: #fff; border: 1px solid #333; padding: 10px; cursor: pointer; font-family: inherit; font-size: 10px; font-weight: bold; transition: 0.1s; }
        button:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        
        input[type="file"] { font-size: 9px; color: #555; background: #000; padding: 8px; border: 1px solid #222; margin-bottom: 5px; width: 100%; box-sizing: border-box; }
        .danger { color: #ff0044; }
    </style>
</head>
<body>

<div class="sidebar">
    <h1>PNG DESTROYER</h1>
    <div class="version">BUILD: SIGNAL_DEAD_V10.0</div>
    
    <input type="file" id="upload" accept="image/*">
    <div class="btn-row">
        <button id="random">RANDOMIZE</button>
        <button id="download">SAVE_RESULT</button>
    </div>

    <div class="group">
        <div class="group-title">Geometry: Signal Tear</div>
        <label>Stride Skew <span class="val" id="v-skew">0</span></label>
        <input type="range" id="skew" min="-100" max="100" value="0">
        <label>Block Slide <span class="val" id="v-slide">0</span></label>
        <input type="range" id="slide" min="0" max="1000" value="0">
        <label>Sync Loss (Interlace) <span class="val" id="v-sync">0</span></label>
        <input type="range" id="sync" min="0" max="200" value="0">
    </div>

    <div class="group">
        <div class="group-title">Color: Chromatic Decay</div>
        <label>Ghosting (Echo) <span class="val" id="v-echo">0</span></label>
        <input type="range" id="echo" min="0" max="100" value="0">
        <label>Bit Rot (Crush) <span class="val" id="v-crush">0</span></label>
        <input type="range" id="crush" min="0" max="7" value="0">
        <label>RGB Split Loop <span class="val" id="v-rgb">0</span></label>
        <input type="range" id="rgb" min="0" max="300" value="0">
    </div>

    <div class="group">
        <div class="group-title">Logic: Binary Overflow</div>
        <label>Overflow (Modulo) <span class="val" id="v-mult">1</span></label>
        <input type="range" id="mult" min="1" max="10" value="1" step="0.1">
        <label>XOR Bit Noise <span class="val" id="v-bit">0</span></label>
        <input type="range" id="bit" min="0" max="8" value="0">
        <label>Stability <span class="val" id="v-stable">0</span></label>
        <input type="range" id="stable" min="0" max="300" value="0">
    </div>

    <div class="group">
        <div class="group-title">Melt: Acid Erosion</div>
        <label class="danger">Acid Melt (Vertical) <span class="val" id="v-melt">0</span></label>
        <input type="range" id="melt" min="0" max="255" value="0">
        <label>Sort Threshold <span class="val" id="v-sort">0</span></label>
        <input type="range" id="sort" min="0" max="255" value="0">
    </div>
</div>

<div class="viewport">
    <canvas id="canvas"></canvas>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let originalImageData = null;

    const params = ['skew', 'slide', 'sync', 'echo', 'crush', 'rgb', 'mult', 'bit', 'stable', 'melt', 'sort'];
    const els = {};
    params.forEach(p => {
        els[p] = document.getElementById(p);
        els[p].oninput = () => {
            document.getElementById(`v-${p}`).innerText = els[p].value;
            applyGlitch();
        };
    });

    document.getElementById('upload').onchange = (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const img = new Image();
            img.onload = () => {
                canvas.width = img.width; canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                originalImageData = ctx.getImageData(0, 0, img.width, img.height);
                applyGlitch();
            };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    };

    document.getElementById('random').onclick = () => {
        params.forEach(p => {
            const min = parseFloat(els[p].min), max = parseFloat(els[p].max);
            els[p].value = (Math.random() * (max - min) + min).toFixed(1);
            document.getElementById(`v-${p}`).innerText = els[p].value;
        });
        applyGlitch();
    };

    document.getElementById('download').onclick = () => {
        canvas.toBlob((blob) => {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `PNG_DESTROYER_V10_${Date.now()}.png`;
            link.click();
        }, 'image/png');
    };

    function getIdx(x, y, w, h) {
        return ((y + h) % h * w + (x + w) % w) * 4;
    }

    function applyGlitch() {
        if (!originalImageData) return;
        const { width, height, data } = originalImageData;
        const out = new ImageData(new Uint8ClampedArray(data), width, height);
        const cfg = {};
        params.forEach(p => cfg[p] = parseFloat(els[p].value));

        // PASS 1: Spatial & Logical Destruction
        for (let y = 0; y < height; y++) {
            // Stride Skew & Interlace Sync Loss logic
            const syncOffset = (y % 2 === 0) ? cfg.sync : -cfg.sync;
            const skewOffset = Math.floor(y * (cfg.skew / 10));
            const xBaseShift = (Math.floor(y / 10) % 2 === 0) ? cfg.slide : 0;
            const totalXShift = xBaseShift + skewOffset + syncOffset;

            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const ti = getIdx(x + totalXShift, y, width, height);
                
                let r = data[ti], g = data[ti+1], b = data[ti+2];

                // Stability (PNG Filter logic)
                if (cfg.stable > 0 && y > 0) {
                    const pi = getIdx(x, y - 1, width, height);
                    const refR = out.data[pi], refG = out.data[pi+1], refB = out.data[pi+2];
                    r = (r + refR * (cfg.stable/100)) % 256;
                    g = (g + refG * (cfg.stable/100)) % 256;
                    b = (b + refB * (cfg.stable/100)) % 256;
                }

                // Modulo Chaos (Overflow)
                if (cfg.mult !== 1) {
                    r = (r * cfg.mult) % 256;
                    g = (g * cfg.mult) % 256;
                    b = (b * cfg.mult) % 256;
                }

                // Bit Rot (Crush)
                if (cfg.crush > 0) {
                    const mask = 0xFF << cfg.crush;
                    r &= mask; g &= mask; b &= mask;
                }

                // XOR Bit Noise
                if (cfg.bit > 0) { r ^= (r >> cfg.bit); g ^= (g >> cfg.bit); b ^= (b >> cfg.bit); }

                out.data[i] = r; out.data[i+1] = g; out.data[i+2] = b; out.data[i+3] = 255;
            }
        }

        // PASS 2: Acid Melt & Post Effects
        const temp = new Uint8ClampedArray(out.data);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;

                // Acid Melt (Vertical Pixel Sort)
                if (cfg.melt > 0 && y > 0) {
                    const up = getIdx(x, y - 1, width, height);
                    const brightness = (temp[i] + temp[i+1] + temp[i+2]) / 3;
                    const upBrightness = (out.data[up] + out.data[up+1] + out.data[up+2]) / 3;
                    if (Math.abs(brightness - upBrightness) < cfg.melt) {
                        out.data[i] = out.data[up];
                        out.data[i+1] = out.data[up+1];
                        out.data[i+2] = out.data[up+2];
                    }
                }

                // Ghosting (Echo) & RGB Split
                if (cfg.echo > 0 || cfg.rgb > 0) {
                    const echoY = Math.floor(y - (cfg.echo / 2));
                    const shiftX = Math.floor(cfg.rgb);
                    
                    const ri = getIdx(x + shiftX, echoY, width, height);
                    const bi = getIdx(x - shiftX, y, width, height);
                    
                    // Rに過去(Echo)のBを混ぜるような混線
                    out.data[i] = (out.data[i] * 0.6 + temp[ri] * 0.4);
                    out.data[i+2] = (out.data[i+2] * 0.6 + temp[bi+2] * 0.4);
                }
            }
        }
        ctx.putImageData(out, 0, 0);
    }
</script>
</body>
</html>
